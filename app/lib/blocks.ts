// Removed "use server" for static export compatibility
import { promises as fs } from "fs"
import { tmpdir } from "os"
import path from "path"
import { Index } from "@/__registry__"
import { Project, ScriptKind, SourceFile, SyntaxKind } from "ts-morph"
import { z } from "zod"

import { highlightCode } from "@/lib/highlight-code"
import { BlockChunk } from "@/registry/schema"
import { Style } from "@/registry/styles"

const DEFAULT_BLOCKS_STYLE = "default" satisfies Style["name"]

const project = new Project({
  compilerOptions: {},
})

export async function getAllBlockIds(
  types?: string[],
  categories?: string[],
  style: Style["name"] = DEFAULT_BLOCKS_STYLE
) {
  const blocks = await getAllBlocks(
    types ?? ["components:block"],
    categories ?? [],
    style
  )

  return blocks.map((block) => block.name)
}

export async function getAllBlocks(
  types: string[] = ["components:block"],
  categories: string[] = [],
  style: Style["name"] = DEFAULT_BLOCKS_STYLE
) {
  // Collect all blocks from the specified style
  const allBlocks: any[] = []
  const styleIndex = Index[style]

  if (typeof styleIndex === "object" && styleIndex !== null) {
    for (const itemName in styleIndex) {
      const item = styleIndex[itemName]
      allBlocks.push(item)
    }
  }

  // Filter by type and categories (registry is generated by build script, no validation needed)
  return allBlocks.filter((block) => {
    const matchesType = types.includes(block.type)

    // Extract category from block name (e.g., "sidebar-01" -> "sidebar")
    const blockCategory = block.name.split("-")[0]
    const matchesCategory =
      categories.length === 0 || categories.includes(blockCategory)

    return matchesType && matchesCategory
  })
}

export async function getBlock(
  name: string,
  style: Style["name"] = DEFAULT_BLOCKS_STYLE
) {
  const entry = Index[style][name]

  // Return null if block doesn't exist
  if (!entry) {
    return null
  }

  // Skip validation - we control registry generation and know it's correct
  const content = await _getBlockContent(name, style)

  const chunks = await Promise.all(
    entry.chunks?.map(async (chunk: BlockChunk) => {
      const code = await readFile(chunk.file)

      const tempFile = await createTempSourceFile(`${chunk.name}.tsx`)
      const sourceFile = project.createSourceFile(tempFile, code, {
        scriptKind: ScriptKind.TSX,
      })

      sourceFile
        .getDescendantsOfKind(SyntaxKind.JsxOpeningElement)
        .filter((node) => {
          return node.getAttribute("x-chunk") !== undefined
        })
        ?.map((component) => {
          component
            .getAttribute("x-chunk")
            ?.asKind(SyntaxKind.JsxAttribute)
            ?.remove()
        })

      return {
        ...chunk,
        code: sourceFile
          .getText()
          .replaceAll(`@/registry/${style}/`, "@/components/"),
      }
    }) ?? []
  )

  // Skip validation - return object directly
  return {
    style,
    highlightedCode: content.code ? await highlightCode(content.code) : "",
    ...entry,
    ...content,
    chunks,
    type: "components:block",
  }
}

async function _getBlockCode(
  name: string,
  style: Style["name"] = DEFAULT_BLOCKS_STYLE
) {
  const entry = Index[style][name]

  if (!entry?.source) {
    return ""
  }

  return await readFile(entry.source)
}

async function readFile(source: string) {
  const filepath = path.join(process.cwd(), source)
  return await fs.readFile(filepath, "utf-8")
}

async function createTempSourceFile(filename: string) {
  const dir = await fs.mkdtemp(path.join(tmpdir(), "codex-"))
  return path.join(dir, filename)
}

async function _getBlockContent(name: string, style: Style["name"]) {
  const raw = await _getBlockCode(name, style)

  const tempFile = await createTempSourceFile(`${name}.tsx`)
  const sourceFile = project.createSourceFile(tempFile, raw, {
    scriptKind: ScriptKind.TSX,
  })

  // Extract meta.
  const description = _extractVariable(sourceFile, "description")
  const iframeHeight = _extractVariable(sourceFile, "iframeHeight")
  const containerClassName = _extractVariable(sourceFile, "containerClassName")

  // Format the code.
  let code = sourceFile.getText()
  code = code.replaceAll(`@/registry/${style}/`, "@/components/")
  code = code.replaceAll("export default", "export")

  return {
    description: description ?? undefined,
    code,
    container: {
      height: iframeHeight ?? undefined,
      className: containerClassName ?? undefined,
    },
  }
}

function _extractVariable(sourceFile: SourceFile, name: string) {
  const variable = sourceFile.getVariableDeclaration(name)
  if (!variable) {
    return null
  }

  const value = variable
    .getInitializerIfKindOrThrow(SyntaxKind.StringLiteral)
    .getLiteralValue()

  variable.remove()

  return value
}

// Force recompile
